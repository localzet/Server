<?php declare(strict_types=1);

/**
 * @package     Localzet Server
 * @link        https://github.com/localzet/Server
 *
 * @author      Ivan Zorin <creator@localzet.com>
 * @copyright   Copyright (c) 2018-2024 Localzet Group
 * @license     https://www.gnu.org/licenses/agpl-3.0 GNU Affero General Public License v3.0
 *
 *              This program is free software: you can redistribute it and/or modify
 *              it under the terms of the GNU Affero General Public License as published
 *              by the Free Software Foundation, either version 3 of the License, or
 *              (at your option) any later version.
 *
 *              This program is distributed in the hope that it will be useful,
 *              but WITHOUT ANY WARRANTY; without even the implied warranty of
 *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *              GNU Affero General Public License for more details.
 *
 *              You should have received a copy of the GNU Affero General Public License
 *              along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 *              For any questions, please contact <creator@localzet.com>
 */

namespace localzet\Server\Events\Linux;

use Closure;
use Error;
use Throwable;

/**
 * Драйвер ДОЛЖЕН работать в своем собственном Fiber'е и выполнять обратные вызовы в отдельном Fiber'е. Если Fiber'ы повторно используются, драйвер
 * должен вызвать {@see FiberLocal::clear()} после выполнения обратного вызова.
 */
interface Driver
{
    /**
     * Запустить цикл обработки событий.
     *
     * Одна итерация цикла называется "тиком". Тик охватывает следующие шаги:
     *
     *  1. Активировать обратные вызовы, созданные / включенные в последнем тике / до `run()`.
     *  2. Выполнить все включенные отложенные обратные вызовы.
     *  3. Выполнить все обратные вызовы таймера, ожидающие сигнала и действующие потоковые обратные вызовы, каждый только один раз за тик.
     *
     * Цикл ДОЛЖЕН продолжать работу до тех пор, пока он не будет остановлен явно, не останется ссылочных обратных вызовов, или не будет выброшено
     * исключение, которое невозможно обработать. Исключениями, которые невозможно обработать, являются исключения, выброшенные из
     * обработчика ошибок или исключения, которые должны быть переданы обработчику ошибок, но нет ни одного, который мог бы их обработать.
     *
     * @throws Error Выбрасывается, если цикл обработки событий уже запущен.
     */
    public function run(): void;

    /**
     * Остановить цикл обработки событий.
     *
     * Когда цикл обработки событий останавливается, он продолжает свой текущий тик и выходит из цикла после этого. Многократные вызовы
     * остановки ДОЛЖНЫ быть проигнорированы и НЕ ДОЛЖНЫ вызывать исключение.
     */
    public function stop(): void;

    /**
     * Возвращает объект, используемый для приостановки и возобновления выполнения текущего Fiber'а или {main}.
     *
     * Вызовы из одного и того же Fiber'а вернут один и тот же объект приостановки.
     *
     * @return Suspension
     */
    public function getSuspension(): Suspension;

    /**
     * @return bool True если цикл обработки событий работает, false если он остановлен.
     */
    public function isRunning(): bool;

    /**
     * Поставить в очередь микрозадачу.
     *
     * Поставленный в очередь обратный вызов ДОЛЖЕН быть выполнен сразу, как только цикл событий получит управление. Порядок постановки в очередь ДОЛЖЕН быть
     * сохранен при выполнении обратных вызовов. Рекурсивное планирование может привести к бесконечным циклам, используйте с осторожностью.
     *
     * НЕ создает обратный вызов события, поэтому НЕ МОЖЕТ быть помечен как отключенный или непривязанный.
     * Используйте {@see EventLoop::defer()} если вам нужны эти функции.
     *
     * @param Closure $closure (...):void $closure Обратный вызов для постановки в очередь.
     * @param mixed ...$args Аргументы обратного вызова.
     */
    public function queue(Closure $closure, mixed ...$args): void;

    /**
     * Отложить выполнение обратного вызова.
     *
     * Отложенный обратный вызов ДОЛЖЕН быть выполнен до любого другого типа обратного вызова в тике. Порядок включения ДОЛЖЕН быть
     * сохранен при выполнении обратных вызовов.
     *
     * Созданный обратный вызов ДОЛЖЕН немедленно быть помечен как включенный, но только быть активирован (т.е. обратный вызов может быть вызван)
     * прямо перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param Closure(string):void $closure Обратный вызов для отложения. `$callbackId` будет аннулирован перед
     *     вызовом обратного вызова.
     *
     * @return string Уникальный идентификатор, который можно использовать для отмены, включения или отключения обратного вызова.
     */
    public function defer(Closure $closure): string;

    /**
     * Задержать выполнение обратного вызова.
     *
     * Задержка является минимальной и приблизительной, точность не гарантируется. Порядок вызовов ДОЛЖЕН определяться тем,
     * какие таймеры истекают первыми, но таймеры с одинаковым временем истечения МОГУТ выполняться в любом порядке.
     *
     * Созданный обратный вызов ДОЛЖЕН немедленно быть помечен как включенный, но только быть активирован (т.е. обратный вызов может быть вызван)
     * прямо перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param float $delay Время, в секундах, на которое следует задержать выполнение.
     * @param Closure(string):void $closure Обратный вызов для задержки. `$callbackId` будет аннулирован перед
     *     вызовом обратного вызова.
     *
     * @return string Уникальный идентификатор, который можно использовать для отмены, включения или отключения обратного вызова.
     */
    public function delay(float $delay, Closure $closure): string;

    /**
     * Повторно выполнить обратный вызов.
     *
     * Интервал между выполнениями является минимальным и приблизительным, точность не гарантируется. Порядок вызовов ДОЛЖЕН
     * определяться тем, какие таймеры истекают первыми, но таймеры с одинаковым временем истечения МОГУТ выполняться в любом порядке.
     * Первое выполнение запланировано после первого периода интервала.
     *
     * Созданный обратный вызов ДОЛЖЕН немедленно быть помечен как включенный, но только быть активирован (т.е. обратный вызов может быть вызван)
     * прямо перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param float $interval Временной интервал, в секундах, который следует ожидать между выполнениями.
     * @param Closure(string):void $closure Обратный вызов для повторения.
     *
     * @return string Уникальный идентификатор, который можно использовать для отмены, включения или отключения обратного вызова.
     */
    public function repeat(float $interval, Closure $closure): string;

    /**
     * Выполнить обратный вызов, когда потоковый ресурс станет доступным для чтения или будет закрыт для чтения.
     *
     * Предупреждение: Локальное закрытие ресурсов, например, с помощью `fclose`, может не вызывать обратный вызов. Обязательно `cancel`
     * обратный вызов при локальном закрытии ресурса. Драйверы МОГУТ выбрать уведомление пользователя, если есть обратные вызовы на
     * недействительных ресурсах, но не обязаны это делать из-за высокого влияния на производительность. Обратные вызовы на закрытых ресурсах являются
     * поэтому неопределенное поведение.
     *
     * Множественные обратные вызовы на одном и том же потоке МОГУТ выполняться в любом порядке.
     *
     * Созданный обратный вызов ДОЛЖЕН немедленно быть помечен как включенный, но только быть активирован (т.е. обратный вызов может быть вызван)
     * прямо перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param resource $stream Поток для мониторинга.
     * @param Closure(string, resource):void $closure Обратный вызов для выполнения.
     *
     * @return string Уникальный идентификатор, который можно использовать для отмены, включения или отключения обратного вызова.
     */
    public function onReadable(mixed $stream, Closure $closure): string;

    /**
     * Выполнить обратный вызов, когда потоковый ресурс станет доступным для записи или будет закрыт для записи.
     *
     * Предупреждение: Локальное закрытие ресурсов, например, с помощью `fclose`, может не вызывать обратный вызов. Обязательно `cancel`
     * обратный вызов при локальном закрытии ресурса. Драйверы МОГУТ выбрать уведомление пользователя, если есть обратные вызовы на
     * недействительных ресурсах, но не обязаны это делать из-за высокого влияния на производительность. Обратные вызовы на закрытых ресурсах являются
     * поэтому неопределенное поведение.
     *
     * Множественные обратные вызовы на одном и том же потоке МОГУТ выполняться в любом порядке.
     *
     * Созданный обратный вызов ДОЛЖЕН немедленно быть помечен как включенный, но только быть активирован (т.е. обратный вызов может быть вызван)
     * прямо перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param resource $stream Поток для мониторинга.
     * @param Closure(string, resource):void $closure Обратный вызов для выполнения.
     *
     * @return string Уникальный идентификатор, который можно использовать для отмены, включения или отключения обратного вызова.
     */
    public function onWritable(mixed $stream, Closure $closure): string;

    /**
     * Выполнить обратный вызов при получении сигнала.
     *
     * Предупреждение: Установка одного и того же сигнала на разных экземплярах этого интерфейса считается неопределенным поведением.
     * Реализации МОГУТ попытаться обнаружить это, если это возможно, но не обязаны это делать. Это связано с техническими
     * ограничениями регистрации сигналов глобально на процесс.
     *
     * Множественные обратные вызовы на одном и том же сигнале МОГУТ выполняться в любом порядке.
     *
     * Созданный обратный вызов ДОЛЖЕН немедленно быть помечен как включенный, но только быть активирован (т.е. обратный вызов может быть вызван)
     * прямо перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param int $signal Номер сигнала для мониторинга.
     * @param Closure(string, int):void $closure Обратный вызов для выполнения.
     *
     * @return string Уникальный идентификатор, который можно использовать для отмены, включения или отключения обратного вызова.
     *
     * @throws UnsupportedFeatureException Если обработка сигналов не поддерживается.
     */
    public function onSignal(int $signal, Closure $closure): string;

    /**
     * Включить обратный вызов для активации начиная со следующего тика.
     *
     * Обратные вызовы ДОЛЖНЫ немедленно быть помечены как включенные, но только быть активированы (т.е. обратные вызовы могут быть вызваны) прямо
     * перед следующим тиком. Обратные вызовы НЕ ДОЛЖНЫ вызываться в тике, в котором они были включены.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return string Идентификатор обратного вызова.
     *
     * @throws InvalidCallbackError Если идентификатор обратного вызова недействителен.
     */
    public function enable(string $callbackId): string;

    /**
     * Отменить обратный вызов.
     *
     * Это отключит цикл обработки событий от всех ресурсов, которые связаны с обратным вызовом. После этой операции
     * обратный вызов становится постоянно недействительным. Вызов этой функции НЕ ДОЛЖЕН завершаться неудачей, даже если передан недействительный идентификатор.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     */
    public function cancel(string $callbackId): void;

    /**
     * Немедленно отключить обратный вызов.
     *
     * Обратный вызов ДОЛЖЕН быть отключен немедленно, например, если отложенный обратный вызов отключает последующий отложенный обратный вызов,
     * второй отложенный обратный вызов не выполняется в этом тике.
     *
     * Отключение обратного вызова НЕ ДОЛЖНО аннулировать обратный вызов. Вызов этой функции НЕ ДОЛЖЕН завершаться неудачей, даже если передан
     * недействительный идентификатор обратного вызова.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return string Идентификатор обратного вызова.
     */
    public function disable(string $callbackId): string;

    /**
     * Сделать обратный вызов ссылочным.
     *
     * Это будет поддерживать цикл обработки событий в активном состоянии, пока обратный вызов все еще контролируется. Обратные вызовы имеют это состояние по
     * умолчанию.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return string Идентификатор обратного вызова.
     *
     * @throws InvalidCallbackError Если идентификатор обратного вызова недействителен.
     */
    public function reference(string $callbackId): string;

    /**
     * Сделать обратный вызов нереферентным.
     *
     * Цикл обработки событий должен выйти из метода run, когда только нереферентные обратные вызовы все еще контролируются. Обратные вызовы
     * все являются ссылочными по умолчанию.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return string Идентификатор обратного вызова.
     */
    public function unreference(string $callbackId): string;

    /**
     * Установить обратный вызов для выполнения, когда происходит ошибка.
     *
     * Обратный вызов получает ошибку как первый и единственный параметр. Возвращаемое значение обратного вызова игнорируется.
     * Если он не может обработать ошибку, он ДОЛЖЕН выбросить ошибку. Ошибки, выброшенные обратным вызовом или во время его вызова
     * ДОЛЖНЫ быть выброшены в цикл `run` и остановить драйвер.
     *
     * Последующие вызовы этого метода перезапишут предыдущий обработчик.
     *
     * @param null|Closure(Throwable):void $errorHandler Обратный вызов для выполнения. `null` очистит текущий
     *     обработчик.
     */
    public function setErrorHandler(?Closure $errorHandler): void;

    /**
     * Получает замыкание обработчика ошибок или {@code null}, если его нет.
     *
     * @return null|Closure(Throwable):void Предыдущий обработчик, `null`, если его не было.
     */
    public function getErrorHandler(): ?Closure;

    /**
     * Получить базовый дескриптор цикла.
     *
     * Пример: ресурс `uv_loop` для `libuv` или объект `EvLoop` для `libev` или `null` для драйвера stream_select.
     *
     * Примечание: Эта функция *не* представлена в классе `Loop`. Пользователи должны получить доступ к ней напрямую на соответствующем экземпляре цикла
     *
     * @return null|object|resource Дескриптор цикла, на котором работает цикл событий. `null`, если его нет.
     */
    public function getHandle(): mixed;

    /**
     * Возвращает все зарегистрированные неотмененные идентификаторы обратных вызовов.
     *
     * @return string[] Идентификаторы обратных вызовов.
     */
    public function getIdentifiers(): array;

    /**
     * Возвращает тип обратного вызова, определенный данным идентификатором обратного вызова.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return CallbackType Тип обратного вызова.
     */
    public function getType(string $callbackId): CallbackType;

    /**
     * Возвращает, включен ли в настоящее время обратный вызов, определенный данным идентификатором обратного вызова.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return bool {@code true}, если обратный вызов в настоящее время включен, в противном случае {@code false}.
     */
    public function isEnabled(string $callbackId): bool;

    /**
     * Возвращает, является ли в настоящее время обратный вызов, определенный данным идентификатором обратного вызова, ссылочным.
     *
     * @param string $callbackId Идентификатор обратного вызова.
     *
     * @return bool {@code true}, если обратный вызов в настоящее время является ссылочным, в противном случае {@code false}.
     */
    public function isReferenced(string $callbackId): bool;

    /**
     * Возвращает некоторую полезную информацию о цикле обработки событий.
     *
     * Если этот метод не реализован, то дамп цикла обработки событий в активном приложении, даже косвенно, будет затруднительным.
     *
     * @return array
     */
    public function __debugInfo(): array;
}